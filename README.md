# Drone Interactive Simulator for Advanced robot programming

## Overview
This project is a multi-process interactive simulator designed to operate a drone within a 2D environment.
The system simulates the physical dynamics of a drone (inertia and viscous resistance), allowing the user to navigate through obstacles and reach targets using keyboard controls.

<img width="1325" height="597" alt="image" src="https://github.com/user-attachments/assets/cdb89ebe-8222-45cd-a9d1-44967935e371" />


The visual interface is built using the `ncurses` library, providing a lightweight, terminal-based simulation.

## System Architecture
The application is designed as a distributed system involving six active concurrent processes communicating mainly via Pipes.

<img width="80%" height="80%" alt="Blackboard(3)(1)" src="https://github.com/user-attachments/assets/98f103e1-a11e-455b-8d3a-2a38bf8bcc4a" />


### Components
The system follows a blackboard architecture:
1.  **Blackboard:** The central server. It maintains the geometrical state of the world (drone position, map, targets, obstacles) and manages communication between processes.
2.  **Drone:** Calculates the physics of the drone, including mass, friction, and external forces, solving the motion equations.
3.  **Input:** Captures keyboard inputs from the user and sends command forces to the server.
4.  **Obstacles:** Spawns obstacles at random locations that repel the drone.
5.  **Targets:** Spawns targets with attractive force that the drone must collect. Handle the score system.
6. **Master:** Launch every process.
7. **Watchdog:** Periodically check if every process works correctly and handle the situation in case of errors. It poll each process through signal.

<img width="50%" height="50%" alt="image" src="https://github.com/user-attachments/assets/939b7f85-430c-41c0-b43d-39b4c0fe8748" />

The following scheme illustrate the sequential steps computed at runtime:

<img width="70%" height="70%" alt="Blackboard(2)(1)" src="https://github.com/user-attachments/assets/959b8d41-35a7-4666-8672-401f5c14c700" />

This scheme doesn't integrate the case in which the user is resizing the window.


### Files
* **Parameter File:** Contains all the parameters about the physics (forces, mass, viscousity, time of integration), the protocol of communication via pipes and general setting like the denssity of obstacle or the time for the respawn of objects.
* **Log File:** Contains all the debug, warning and error messages.
* **Log Watchdog:** Cointains the state of all processes.
* **PID File:** Contains the PID of every processes. At the start every process write its own PID in this file.

### Watchdog signals
At the start the watchdog waits every process to read the `PID_file` in order to send the signals. After that it set an alarm that every 5 seconds check if all processes are working correctly.
| Signal | Use |
| --- | --- |
| SIG_WRITTEN | The signal that send every process after have written the PID in the file |
| SIG_PING | The signal that send the watchdog to poll the processes |
| SIG_HEARTBEAT | The signal that send every process to respond the ping |
| SIGALARM | The signal to set the timer |
| SIG_STOP | The signal that use the blackboard to stop the watchdog at the end of the game |
| SIGWINCH | The signal to redraw the window in case of resize |

## Physics & Dynamics
The drone is modeled as a point mass with 2 Degrees of Freedom (DoF). The motion is determined by the following equation of dynamics, solved numerically using Euler's method:

$$\sum F = M \frac{d^2p}{dt^2} + K \frac{dp}{dt}$$

Where:
* $M$ = Mass (Inertia)
* $K$ = Viscous friction coefficient
* $F$ = Sum of all forces applied

### Forces Involved
1.  **Command Forces:** Generated by user keypresses. Forces accumulate in steps to simulate thrust.
2.  **Repulsive Forces:** Generated by obstacles and walls using **Latombe/Khatib’s model**.
   
$$\sum F = \eta * (\frac{1}{d} - \frac{1}{\rho})\frac{1}{d^2}$$

The force increases as the drone gets closer to an obstacle, diverging to infinity as distance approaches zero.

>[!NOTE]
>All computations are performed in floating-point precision; only the visual representation is discrete.

## Installation & Requirements

### Prerequisites
* Linux Environment (POSIX compliant)
* GCC Compiler
```
sudo apt install gcc
```
* `ncurses` library:
```
sudo apt-get install libncurses5-dev libncursesw5-dev
```
* Konsole
```
sudo apt install konsole
```
* Clone the repositery
```
git clone https://github.com/TZTozz/ARP-Assignment.git
cd ARP-Assignment
```

## Usage
### Launch the program
```
./launcher.sh
```
### Control the drone
The drone is controlled via the keyboard. The the following keys increase the force in the specific direction (relative to the key D).
The key D is the brake and halves the force.
```
┌───┬───┬───┐
│ W │ E │ R │
├───┼───┼───┤
│ S │ D │ F │
├───┼───┼───┤
│ X │ C │ V │
└───┴───┴───┘
```
### Visual elements
* ${\color{magenta}"+"}$: the drone
* ${\color{green}"1"}$: targets
* ${\color{red}"0"}$: obstacles

### How to play
Use the keyboard to reach the target in the right order. Pay attention to not go too close the wrong target or you will need a great amount of force to escape from it (10N) and you will lose points. You need to be fast, there is a malus for the time. Once you reach the final target the final window will appear.

<img width="935" height="366" alt="image" src="https://github.com/user-attachments/assets/143d74f7-c860-4829-b5d5-90357d9e2ef2" />




## Directory
```
.
├── bin
│   ├── BB
│   ├── drone
│   ├── I_process
│   ├── master
│   ├── obstacles
│   ├── targets
│   └── watchdog
├── files
│   ├── log_file.log
│   ├── PID_file.log
│   └── watchdog.log
├── launcher.sh
├── README.md
└── src
    ├── BB.c
    ├── drone.c
    ├── I_process.c
    ├── logger.c
    ├── logger.h
    ├── master.c
    ├── obstacles.c
    ├── parameter_file.h
    ├── targets.c
    └── watchdog.c

```
